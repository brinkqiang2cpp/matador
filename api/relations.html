---
layout: reference
title: Object Relations
---
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Object Relations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="object_relations_sec"></a>
Object relations</h1>
<p>When it comes to object relations you can use one to one and one to many relations in a straight forward way.</p>
<h2><a class="anchor" id="one_to_one"></a>
OneToOne relations</h2>
<p>In this example we have two object types an address class and a person class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>address : <span class="keyword">public</span> oos::object</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">//...</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::string street_;</div><div class="line">  std::string city_;</div><div class="line">};</div></div><!-- fragment --><p>Each person class should have an address, so we add an oos::object_ptr of type address to the members. That's it. Now we have a one to one relationship beetween two classes.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>person : <span class="keyword">public</span> oos::object</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">//...</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  oos::object_ptr&lt;address&gt; address_;</div><div class="line">};</div></div><!-- fragment --><p>With this kind of relationship we have a hard linked relationship. Which means if we remove the person from our store the address object is removed as well.</p>
<p>In case we want to keep the address object we can use a oos::object_ref of type adress instead of object_ptr.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>person : <span class="keyword">public</span> oos::object</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  oos::object_ref&lt;address&gt; address_;</div><div class="line">};</div></div><!-- fragment --><p>With object_ref we have a soft link to the address inside our person class and it won't be removed on a person removal. We must explicitly remove the address.</p>
<h2><a class="anchor" id="one_to_many"></a>
OneToMany relations</h2>
<p>When it comes to one to many releationships it is also quiet easy. OOS comes with three types of container classes which can be used to setup one to many relationships.</p><ul>
<li>oos::object_vector</li>
<li>oos::object_list</li>
<li>oos::linked_object_list</li>
</ul>
<p>Because these classes are designed in the same way as the STL classes we can use them in the same way plus the benefit of the relationship.</p>
<p>Our handy person class needs a list of friends which are also of type person. And because we want this list with soft linked person we use oos::object_ref as the type of the list.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>person : <span class="keyword">public</span> oos::object</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// the value type of the list</span></div><div class="line">  <span class="keyword">typedef</span> oos::object_ref&lt;person&gt; person_ref;</div><div class="line">  <span class="comment">// the list definition</span></div><div class="line">  <span class="keyword">typedef</span> oos::object_list&lt;person_ref&gt; person_list_t;</div><div class="line">  <span class="comment">// shortcuts to the iterators</span></div><div class="line">  <span class="keyword">typedef</span> person_list_t::iterator iterator;</div><div class="line">  <span class="keyword">typedef</span> person_list_t::const_iterator const_iterator;</div><div class="line"></div><div class="line">  <span class="comment">// c&#39;tor for person</span></div><div class="line">  person(<span class="keyword">const</span> std::string &amp;name)</div><div class="line">    : name_(name)</div><div class="line">    <span class="comment">// the list need the person to handle the relationship</span></div><div class="line">    , friends_(this) </div><div class="line">  {}</div><div class="line"></div><div class="line">  std::string name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> name_; }</div><div class="line"></div><div class="line">  <span class="comment">// add a friend to persons friend list</span></div><div class="line">  <span class="keywordtype">void</span> add_friend(<span class="keyword">const</span> person_ref &amp;p)</div><div class="line">  {</div><div class="line">    friends_.push_back(p);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// STL like iterators</span></div><div class="line">  iterator begin() { <span class="keywordflow">return</span> friends_.begin(); }</div><div class="line">  iterator end() { <span class="keywordflow">return</span> friends_.end(); }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::string name_;</div><div class="line">  person_list_t friends_;</div><div class="line">};</div></div><!-- fragment --><p>Why declare a list if we don't use it? Next is an example howto to use our persons friend list.</p>
<p>We insert a new person into the object_store. Than we insert and immediatily add some persons as friends to our first person.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> oos::object_ptr&lt;person&gt; person_ptr;</div><div class="line"></div><div class="line"><span class="comment">// create a new person</span></div><div class="line">person_ptr p = ostore.insert(<span class="keyword">new</span> person(<span class="stringliteral">&quot;joe&quot;</span>));</div><div class="line"></div><div class="line"><span class="comment">// add some friends</span></div><div class="line">p-&gt;add_friend(ostore.insert(<span class="keyword">new</span> person(<span class="stringliteral">&quot;walter&quot;</span>)));</div><div class="line">p-&gt;add_friend(ostore.insert(<span class="keyword">new</span> person(<span class="stringliteral">&quot;helen&quot;</span>)));</div><div class="line">p-&gt;add_friend(ostore.insert(<span class="keyword">new</span> person(<span class="stringliteral">&quot;tim&quot;</span>)));</div></div><!-- fragment --><p>Now we can simply iterate over the list like we used to do it with all STL containers. Period.</p>
<div class="fragment"><div class="line"><span class="comment">// access all friends</span></div><div class="line">person::iterator i = p-&gt;begin();</div><div class="line"><span class="keywordflow">for</span> (i; i != p-&gt;end(); ++i) {</div><div class="line">  std::cout &lt;&lt; i-&gt;value()-&gt;name() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
