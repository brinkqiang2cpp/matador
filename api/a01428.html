---
title: Object Store
---
<!-- Generated by Doxygen 1.8.12 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Object Store </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="store_sec"></a>
Object Store</h1>
<p>Now that you've written your entity classes you might want to insert them into the oos::object_store. But before doing so you have to tell the oos::object_store about your entity hierarchy once.</p>
<h2><a class="anchor" id="prototypes"></a>
Setup object hierarchy</h2>
<p>Assume we have the abstract base class Vehicle and derived from this classes Truck, Car and Bike. Now lets make this hierarchy known to the oos::object_store:</p>
<div class="fragment"><div class="line">oos::object_store ostore;</div><div class="line">ostore.insert_prototype&lt;Vehicle&gt;(<span class="stringliteral">&quot;vehicle&quot;</span>, <span class="keyword">true</span>);</div><div class="line">ostore.insert_prototype&lt;Truck, Vehicle&gt;(<span class="stringliteral">&quot;truck&quot;</span>);</div><div class="line">ostore.insert_prototype&lt;Car, Vehicle&gt;(<span class="stringliteral">&quot;car&quot;</span>);</div><div class="line">ostore.insert_prototype&lt;Bike, Vehicle&gt;(<span class="stringliteral">&quot;bike&quot;</span>);</div></div><!-- fragment --><p>As you can see it is quite simple to add the hierarchy to the oos::object_store by calling method oos::object_store::insert_prototype. As there are several ways to call this method we decide to use the one with template arguments.</p>
<p>The Vehicle class is an abstract base (directly derived from oos::object). Here we need only one template argument (the class itself: Vehicle). With the first method paramter you give your type a unique name. The second parameter is a flag telling the oos::object_store that this type is abstract. Settings this flag to true you can't insert objects of this concrete type.</p>
<h2><a class="anchor" id="add_objects"></a>
Add objects</h2>
<p>Now that we've setup up our hierarchy we can add new objects to the oos::object_store.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> object_ptr&lt;vehicle&gt; vehicle_ptr;</div><div class="line"></div><div class="line">vehicle_ptr truck = ostore.insert(<span class="keyword">new</span> Truck(<span class="stringliteral">&quot;MAN&quot;</span>);</div><div class="line">vehicle_ptr car   = ostore.insert(<span class="keyword">new</span> Car(<span class="stringliteral">&quot;VW Beetle&quot;</span>);</div><div class="line">vehicle_ptr bike  = ostore.insert(<span class="keyword">new</span> Bike(<span class="stringliteral">&quot;Honda&quot;</span>);</div></div><!-- fragment --><p>As you can see we use <a class="el" href="/api/a00930/index.html" title="The object_ptr holds a pointer to an serializable. ">oos::object_ptr</a> of type vehicle. The vehicle class in our example is the abstract base class for all concrete vehicle types. So the concrete vehicle object is inserted correctly and assigned to the object_ptr.</p>
<p>That means once you have inserted an object of any concrete type you access it via an appropriate object_ptr afterwards. You should never work with the raw instance pointer. This could lead to inconsistencies.</p>
<h2><a class="anchor" id="modify_objects"></a>
Modify objects</h2>
<p>Now that we have some objects inserted we may want to modify them. The important thing here is as mentioned above that you don't deal with raw pointer to your object when try to modify it. You always have a pointer object wrapped around the object (like shared_ptr). The oos::object_store returns an <a class="el" href="/api/a00930/index.html" title="The object_ptr holds a pointer to an serializable. ">oos::object_ptr</a> when an object is inserted. Once you received the <a class="el" href="/api/a00930/index.html" title="The object_ptr holds a pointer to an serializable. ">oos::object_ptr</a> you can change your object by using it like usual pointer.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="/api/a00930/index.html">oos::object_ptr&lt;Truck&gt;</a> truck_ptr;</div><div class="line">truck_ptr truck = ostore.insert(<span class="keyword">new</span> Truck(<span class="stringliteral">&quot;MAN&quot;</span>));</div><div class="line"></div><div class="line">truck-&gt;weight(2.5);</div><div class="line">truck-&gt;color(<span class="stringliteral">&quot;red&quot;</span>);</div></div><!-- fragment --><h2><a class="anchor" id="remove_objects"></a>
Remove objects</h2>
<p>Once we have an object_ptr object we can easily delete this object from the object_store by calling oos::object_store::remove()</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="/api/a00930/index.html">oos::object_ptr&lt;Truck&gt;</a> truck_ptr;</div><div class="line">truck_ptr truck = ostore.insert(<span class="keyword">new</span> Truck(<span class="stringliteral">&quot;MAN&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (ostore.is_removable(truck)) {</div><div class="line">  <span class="comment">// remove object</span></div><div class="line">  ostore.remove(truck);</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">  <span class="comment">// object can&#39;t be removed</span></div><div class="line">}</div></div><!-- fragment --><p>When removing an object internally a check is done if the object (and subsequently all connected objects) can be removed. This test is done by checking the pointer and reference count of each concerning object. If the test succeeds the object is removed and true is returned. If the test fails false is returned. </p>
</div></div><!-- contents -->
